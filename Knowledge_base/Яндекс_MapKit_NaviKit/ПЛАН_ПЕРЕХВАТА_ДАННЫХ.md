# План перехвата данных из Yandex Maps

## Стратегия

### Принцип:

1. **Находим места вызова API** - где Yandex Maps вызывает методы NaviKit API
2. **Находим места сохранения** - где результаты сохраняются в переменные/поля
3. **Перехватываем данные** - модифицируем код для отправки в BridgeService
4. **Разворачиваем в BridgeService** - преобразуем сырые данные в итоговые значения

## 1. Ограничение скорости

### Места для поиска:

- `SpeedLimitPresenter.smali` - презентер для отображения ограничения скорости
- `SpeedLimitView.smali` - view для отображения
- `GuidancePresentersFactory.smali` - фабрика презентеров
- Классы с `getSpeedLimit`, `getLegalSpeedLimit`

### Что искать в smali:

```smali
# Вызов API
invoke-interface {v0}, Lcom/yandex/mapkit/navigation/Guidance;->getSpeedLimit()Lcom/yandex/mapkit/LocalizedValue;

# Сохранение результата
iput-object v1, p0, Lcom/yandex/navikit/ui/guidance/SpeedLimitPresenter;->speedLimit:Lcom/yandex/mapkit/LocalizedValue;
```

### Перехват:

```smali
# После сохранения добавляем:
invoke-static {v1}, Lru/yandex/yandexmaps/bridge/TiggoBridgeSender;->sendSpeedLimit(Lcom/yandex/mapkit/LocalizedValue;)V
```

## 2. Маневры

### Места для поиска:

- Классы с `getUpcomingManoeuvres`, `Manoeuvre`
- Презентеры маневров
- View для отображения маневров

### Что искать:

```smali
# Вызов API
invoke-interface {v0}, Lcom/yandex/mapkit/navigation/Windshield;->getUpcomingManoeuvres()Ljava/util/List;

# Сохранение
iput-object v1, p0, Lcom/yandex/navikit/ui/guidance/ManeuverPresenter;->manoeuvres:Ljava/util/List;
```

### Перехват:

```smali
# После сохранения добавляем:
invoke-static {v1}, Lru/yandex/yandexmaps/bridge/TiggoBridgeSender;->sendManoeuvres(Ljava/util/List;)V
```

## 3. Маршрут (геометрия)

### Места для поиска:

- Классы с `getCurrentRoute`, `DrivingRoute`
- Классы отрисовки маршрута на карте
- Методы получения полилиний/точек маршрута

### Что искать:

```smali
# Вызов API
invoke-interface {v0}, Lcom/yandex/mapkit/navigation/Guidance;->getCurrentRoute()Lcom/yandex/mapkit/navigation/DrivingRoute;

# Получение геометрии
invoke-interface {v1}, Lcom/yandex/mapkit/navigation/DrivingRoute;->getPolyline()Lcom/yandex/mapkit/geometry/Polyline;
```

### Перехват:

```smali
# После получения геометрии добавляем:
invoke-static {v1}, Lru/yandex/yandexmaps/bridge/TiggoBridgeSender;->sendRouteGeometry(Lcom/yandex/mapkit/geometry/Polyline;)V
```

## 4. Карта (тайлы)

### Места для поиска:

- Классы `MapTileProvider`, `TileProvider`
- Методы получения тайлов карты
- Отрисовка карты

### Что искать:

```smali
# Получение тайлов
invoke-interface {v0}, Lcom/yandex/mapkit/map/TileProvider;->getTile(II)Lcom/yandex/mapkit/map/Tile;

# Сохранение тайлов
iput-object v1, p0, Lcom/yandex/mapkit/map/MapView;->tiles:Ljava/util/Map;
```

### Перехват:

```smali
# После получения тайла добавляем:
invoke-static {v1}, Lru/yandex/yandexmaps/bridge/TiggoBridgeSender;->sendMapTile(Lcom/yandex/mapkit/map/Tile;)V
```

## 5. События на карте

### Места для поиска:

- Классы с `Annotator`, `MapEvent`
- Получение камер, пробок, дорожных событий

### Что искать:

```smali
# Получение событий
invoke-interface {v0}, Lcom/yandex/mapkit/navigation/Annotator;->getEvents()Ljava/util/List;
```

### Перехват:

```smali
# После получения событий добавляем:
invoke-static {v1}, Lru/yandex/yandexmaps/bridge/TiggoBridgeSender;->sendMapEvents(Ljava/util/List;)V
```

## Реализация в TiggoBridgeSender

### Новые методы для отправки данных:

```java
public class TiggoBridgeSender {
    // Ограничение скорости
    public static void sendSpeedLimit(LocalizedValue speedLimit) {
        if (speedLimit != null) {
            double valueMs = speedLimit.getValue(); // м/с
            int valueKmh = (int) Math.round(valueMs * 3.6);
            String text = speedLimit.getText();
            sendBroadcast("SPEED_LIMIT", valueKmh, text);
        }
    }

    // Маневры
    public static void sendManoeuvres(List<Manoeuvre> manoeuvres) {
        if (manoeuvres != null && !manoeuvres.isEmpty()) {
            Manoeuvre next = manoeuvres.get(0);
            // Извлекаем данные маневра
            sendBroadcast("MANEUVER", ...);
        }
    }

    // Геометрия маршрута
    public static void sendRouteGeometry(Polyline polyline) {
        if (polyline != null) {
            List<Point> points = polyline.getPoints();
            sendBroadcast("ROUTE_GEOMETRY", points);
        }
    }

    // Тайлы карты
    public static void sendMapTile(Tile tile) {
        if (tile != null) {
            // Отправляем упрощенную модель тайла
            sendBroadcast("MAP_TILE", tile);
        }
    }

    // События на карте
    public static void sendMapEvents(List<MapEvent> events) {
        if (events != null) {
            sendBroadcast("MAP_EVENTS", events);
        }
    }
}
```

## Следующие шаги

1. ⏳ Найти точные места вызова API в декомпилированном коде
2. ⏳ Найти места сохранения результатов
3. ⏳ Создать методы перехвата в TiggoBridgeSender
4. ⏳ Модифицировать smali код для перехвата
5. ⏳ Обновить BridgeService для приема новых данных
6. ⏳ Реализовать разворачивание данных в BridgeService
7. ⏳ Реализовать отправку в QNX
