# Цепочка инициализации навигации в Yandex Navigator

## Обзор

Прослеживание потока данных от запуска приложения до получения данных навигации.

## Главная Activity

**Класс:** `ru.yandex.yandexmaps.app.MapActivity`

**Манифест:**
```xml
<activity-alias 
    android:name="ru.yandex.yandexnavi.core.NavigatorActivity"
    android:targetActivity="ru.yandex.yandexmaps.app.MapActivity">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity-alias>
```

**Роль:** Главная точка входа в приложение.

## DI (Dependency Injection) модули

### 1. Модуль f3.java

**Путь:** `ru.yandex.yandexmaps.app.di.modules.f3`

**Роль:** Создает `GenericGuidance`

**Код:**
```java
public Object get() {
    GenericGuidance genericGuidance = GenericGuidanceComponent.getGenericGuidance();
    return genericGuidance;
}
```

**Цепочка:**
```
GenericGuidanceComponent.INSTANCE
    ↓
getGenericGuidance()
    ↓
GenericGuidance
```

### 2. Модуль p3.java

**Путь:** `ru.yandex.yandexmaps.app.di.modules.p3`

**Роль:** Создает `NotificationDataManager`

**Код:**
```java
public Object get() {
    Guidance guidance = guidanceProvider.get();
    NotificationDataManager notificationDataManager = guidance.notificationDataManager();
    return notificationDataManager;
}
```

**Цепочка:**
```
Guidance (из DI)
    ↓
notificationDataManager()
    ↓
NotificationDataManager
```

## Классы, использующие NotificationDataManager

### 1. ConsistentAutomotiveGuidanceConsumer (класс a.java)

**Путь:** `ru.yandex.yandexmaps.integrations.auto_navigation.navikit.a`

**Наследование:** `BaseAutomotiveGuidanceConsumer`

**Конструктор:**
```java
public a(..., Guidance guidance, ...) {
    super(..., guidance);
    // Получает Guidance, но NotificationDataManager получается через родительский класс
}
```

**Метод onHandlerReady:**
```java
@Override
public void onHandlerReady(GenericGuidanceHandler handler) {
    super.onHandlerReady(handler);
    // Здесь может быть работа с NotificationDataManager
}
```

### 2. Старая версия (класс k.java)

**Путь:** `ru.yandex.yandexmaps.integrations.auto_navigation.navikit.k`

**Наследование:** `BaseGuidanceConsumer`

**Конструктор:**
```java
public k(..., Guidance guidance, ...) {
    super(...);
    NotificationDataManager notificationDataManager = guidance.notificationDataManager();
    this.f180940a = notificationDataManager;  // Сохраняет в поле
    this.f180941b = new i(mainScheduler, notificationDataManager);
}
```

**Метод onHandlerReady:**
```java
@Override
public void onHandlerReady(GenericGuidanceHandler handler) {
    super.onHandlerReady(handler);
    this.f180940a.addListener(this.f180941b);  // Подписывается на обновления
}
```

## Поток данных

### Инициализация

```
1. MapActivity.onCreate()
   ↓
2. DI система создает зависимости
   ↓
3. f3.get() → GenericGuidance
   ↓
4. p3.get() → NotificationDataManager (через Guidance)
   ↓
5. ConsistentAutomotiveGuidanceConsumer создается с Guidance
   ↓
6. onHandlerReady() вызывается
   ↓
7. NotificationDataManager.addListener() вызывается
```

### Получение данных

```
NotificationDataManager
   ↓
onNotificationDataUpdated(NotificationData)
   ↓
Listener получает данные
   ↓
Данные используются для уведомлений/UI
```

## Точки внедрения TiggoBridgeSender

### Вариант 1: В DI модуле p3.java

**Место:** После получения `NotificationDataManager`

**Код:**
```java
NotificationDataManager notificationDataManager = guidance.notificationDataManager();
// ДОБАВИТЬ:
TiggoBridgeSender.init(context);
TiggoBridgeSender.getInstance().attachToNotificationDataManager(notificationDataManager);
return notificationDataManager;
```

**Преимущества:**
- ✅ Централизованно
- ✅ NotificationDataManager создается один раз
- ✅ Гарантированно вызывается

**Недостатки:**
- ⚠️ Нужен доступ к Context

### Вариант 2: В конструкторе ConsistentAutomotiveGuidanceConsumer

**Место:** В конструкторе класса `a.java` (или `k.java` в старой версии)

**Код:**
```java
public a(..., Guidance guidance, ...) {
    super(..., guidance);
    // ДОБАВИТЬ:
    NotificationDataManager manager = guidance.notificationDataManager();
    TiggoBridgeSender.getInstance().attachToNotificationDataManager(manager);
}
```

**Преимущества:**
- ✅ Прямой доступ к Guidance
- ✅ Вызывается при создании consumer

**Недостатки:**
- ⚠️ Нужно найти правильный класс

### Вариант 3: В onHandlerReady

**Место:** В методе `onHandlerReady()` класса `a.java` или `k.java`

**Код:**
```java
@Override
public void onHandlerReady(GenericGuidanceHandler handler) {
    super.onHandlerReady(handler);
    // ДОБАВИТЬ:
    NotificationDataManager manager = getNotificationDataManager(); // через reflection или поле
    TiggoBridgeSender.getInstance().attachToNotificationDataManager(manager);
}
```

**Преимущества:**
- ✅ Вызывается когда handler готов
- ✅ Гарантированно после инициализации

**Недостатки:**
- ⚠️ Нужно получить NotificationDataManager

## Рекомендуемый подход

**Использовать Вариант 2 или 3** - добавить в класс, который уже работает с `NotificationDataManager`.

**Для старой версии (класс k.java):**
- Добавить в конструктор после строки 46:
  ```java
  TiggoBridgeSender.getInstance().attachToNotificationDataManager(this.f180940a);
  ```

**Для новой версии (класс a.java):**
- Нужно найти, где получается `NotificationDataManager`
- Или использовать reflection для получения из `Guidance`

## Следующие шаги

1. ✅ Понять структуру инициализации
2. ⏳ Найти точное место в новой версии APK
3. ⏳ Добавить TiggoBridgeSender
4. ⏳ Протестировать

