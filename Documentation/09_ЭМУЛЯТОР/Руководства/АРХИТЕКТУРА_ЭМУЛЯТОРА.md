# Архитектура эмулятора Chery Tiggo 8 Pro Max

## 🎓 Объяснение "для дураков" - как это работает

### Что такое эмулятор?

Представь, что у тебя есть настоящий автомобиль Chery Tiggo 8 Pro Max с головным устройством (HU). Внутри HU работает Android система и QNX система (для приборной панели).

**Эмулятор** - это программа, которая запускает эти системы на твоем MacBook, как будто это настоящий автомобиль, но без железа.

### Простая аналогия

Это как **виртуальная машина** (как VirtualBox или VMware), но для автомобильной системы:

- Вместо Windows/Linux в виртуальной машине → Android + QNX из реального автомобиля
- Вместо обычного компьютера → эмуляция процессора ARM (как в телефоне)
- Вместо монитора → два виртуальных экрана (один для Android, один для QNX)

### Как это запускается? (Пошагово)

#### Шаг 1: Запуск сервера

```bash
python main.py
```

Что происходит:

1. Запускается веб-сервер на порту 8090
2. Создается `StateManager` - хранит состояние "машины" (зажигание выключено, двери закрыты и т.д.)
3. Создается `IgnitionController` - следит за кнопкой зажигания
4. Сервер готов принимать команды через веб-интерфейс

**Аналогия**: Включаешь компьютер, загружается Windows, открывается браузер.

#### Шаг 2: Нажатие кнопки зажигания (в веб-интерфейсе)

Ты нажимаешь кнопку "Зажигание" в браузере → отправляется запрос на сервер.

Что происходит:

1. `IgnitionController` получает команду "нажата кнопка"
2. Проверяет текущее состояние: "OFF" (выключено)
3. Меняет состояние на "POWER_READY" (первое нажатие)
4. `StateManager` сохраняет новое состояние в файл `data/vehicle_state.json`

**Аналогия**: Поворачиваешь ключ в замке зажигания - машина "просыпается", но двигатель еще не заведен.

#### Шаг 3: Автоматический запуск QNX (приборная панель)

Когда состояние меняется на "POWER_READY", `IgnitionController` понимает: "Нужно запустить QNX!"

Что происходит:

1. `QnxVmManager` получает команду "запустить QNX"
2. Строит команду для QEMU (программа-эмулятор):
   ```bash
   qemu-system-aarch64 -M virt -cpu cortex-a57 -m 2048 \
     -kernel hypervisor-ifs-rcar_h3-graphics.bin \
     -display vnc=127.0.0.1:1 ...
   ```
3. Запускает эту команду как отдельный процесс (subprocess)
4. QEMU начинает эмулировать процессор ARM и загружает QNX образ

**Аналогия**: Включаешь приборную панель в машине - она показывает время, температуру и т.д.

#### Шаг 4: Второе нажатие - запуск Android

Ты нажимаешь кнопку еще раз → состояние меняется на "ACC_ON" (включено зажигание).

Что происходит:

1. `IgnitionController` понимает: "Теперь нужно запустить Android HU!"
2. `EmulatorManager` получает команду "запустить Android"
3. Строит команду для QEMU:
   ```bash
   qemu-system-aarch64 -M virt -cpu cortex-a57 -m 4096 \
     -kernel boot.img \
     -drive file=system.img,format=raw \
     -drive file=vendor.img,format=raw \
     -display vnc=127.0.0.1:0 ...
   ```
4. Запускает QEMU процесс для Android
5. Одновременно запускает `adb logcat` для сбора логов Android

**Аналогия**: Включаешь мультимедиа систему в машине - загружается Android, появляется экран с приложениями.

### Как QEMU запускает образ системы?

#### Что такое QEMU?

**QEMU** - это программа, которая **эмулирует** (симулирует) процессор и устройства компьютера.

**Аналогия**:

- Настоящий компьютер: процессор Intel/AMD, память, диски, видеокарта
- QEMU: программа, которая **притворяется** процессором ARM, памятью, дисками и т.д.

#### Как QEMU загружает Android?

1. **QEMU создает виртуальный процессор ARM**

   - Эмулирует процессор Cortex-A57 (как в реальном автомобиле)
   - Выделяет 4GB виртуальной памяти
   - Создает 4 виртуальных ядра CPU

2. **QEMU загружает kernel (ядро) из boot.img**

   ```
   -kernel boot.img
   ```

   - `boot.img` - это архив, внутри которого:
     - **kernel** (ядро Linux) - "мозг" системы
     - **ramdisk** (начальная файловая система) - временные файлы для загрузки
   - QEMU извлекает kernel и загружает его в виртуальную память по адресу 0x40080000

3. **QEMU передает параметры загрузки (cmdline)**

   ```
   -append "console=ttyAMA0,115200 androidboot.selinux=permissive ..."
   ```

   - Говорит kernel: "Используй этот UART для консоли"
   - "Загружай Android с этими параметрами"

4. **QEMU подключает виртуальные диски**

   ```
   -drive file=system.img,format=raw
   -drive file=vendor.img,format=raw
   ```

   - `system.img` - это образ диска с Android системой (как ISO образ, но для диска)
   - QEMU создает виртуальный жесткий диск и "монтирует" на него этот образ
   - Android видит это как обычный диск `/dev/vda`

5. **Kernel начинает загрузку Android**
   - Kernel читает ramdisk, находит скрипт `/init`
   - `/init` запускается и начинает инициализацию Android
   - Android монтирует `/system` из `system.img`
   - Android запускает все сервисы (launcher, навигация и т.д.)

**Аналогия**:

- Настоящий компьютер: включаешь питание → BIOS загружается → загружается Windows с диска C:
- QEMU: запускаешь QEMU → создается виртуальный процессор → загружается kernel из boot.img → загружается Android с system.img

#### Что такое образы (images)?

**Образ** - это точная копия диска или раздела, сохраненная в файл.

**Аналогия**:

- Образ диска = фотография диска со всем содержимым
- `system.img` = фотография диска с Android системой
- `boot.img` = фотография диска с kernel и начальной файловой системой

Когда QEMU "монтирует" образ:

- QEMU читает файл `system.img`
- Представляет его как виртуальный диск
- Android думает, что это настоящий диск и работает с ним как обычно

### Визуализация процесса запуска

```
1. Ты запускаешь: python main.py
   │
   └─► Запускается веб-сервер (порт 8090)
       └─► Создается StateManager (хранит состояние)
       └─► Создается IgnitionController (следит за кнопкой)

2. Ты нажимаешь кнопку "Зажигание" в браузере
   │
   └─► POST /ignition/press_short
       │
       └─► IgnitionController::handle_short_press()
           │
           ├─► Меняет состояние: OFF → POWER_READY
           │
           └─► Запускает QNX VM:
               │
               └─► QnxVmManager::start()
                   │
                   └─► subprocess.Popen("qemu-system-aarch64 ...")
                       │
                       └─► QEMU процесс запускается
                           │
                           ├─► Создает виртуальный процессор ARM
                           ├─► Загружает kernel из hypervisor-ifs-rcar_h3-graphics.bin
                           ├─► Подключает виртуальные диски (qnx_system.img)
                           └─► QNX начинает загрузку
                               │
                               └─► QNX загружается и показывает приборную панель

3. Ты нажимаешь кнопку еще раз
   │
   └─► POST /ignition/press_short (снова)
       │
       └─► IgnitionController::handle_short_press()
           │
           ├─► Меняет состояние: POWER_READY → ACC_ON
           │
           └─► Запускает Android HU:
               │
               └─► EmulatorManager::start()
                   │
                   └─► subprocess.Popen("qemu-system-aarch64 ...")
                       │
                       └─► QEMU процесс запускается (второй процесс!)
                           │
                           ├─► Создает виртуальный процессор ARM (отдельный от QNX!)
                           ├─► Загружает kernel из boot.img
                           ├─► Подключает виртуальные диски:
                           │   ├─► system.img (Android система)
                           │   ├─► vendor.img (драйверы)
                           │   └─► product.img (приложения)
                           └─► Android начинает загрузку
                               │
                               ├─► Kernel загружается
                               ├─► /init запускается
                               ├─► Android монтирует /system
                               ├─► Запускаются сервисы
                               └─► Появляется launcher (экран с приложениями)
```

### Ключевые моменты

1. **Два независимых QEMU процесса**

   - Один для Android HU (порт 5900 для VNC)
   - Один для QNX Cluster (порт 5901 для VNC)
   - Они работают параллельно, не мешая друг другу

2. **Образы не изменяются**

   - Мы работаем с оригинальными образами из автомобиля
   - QEMU читает их как "только для чтения" (read-only)
   - Все изменения происходят в виртуальной памяти, не в файлах

3. **Все логируется**

   - QEMU stdout → `logs/qemu_stdout.log`
   - Android консоль → `logs/qemu_console.log`
   - Android logcat → `logs/adb_android.log`
   - QNX консоль → сокеты на портах 1236, 1237

4. **Состояние сохраняется**
   - При каждом изменении состояния → сохраняется в `data/vehicle_state.json`
   - При перезапуске сервера → состояние восстанавливается

### Что видит пользователь?

1. **В браузере** (http://localhost:8090/ui):

   - Кнопки управления (зажигание, двери и т.д.)
   - Два окна с дисплеями (HU и Cluster) - получают кадры через VNC
   - Логи в реальном времени

2. **В логах**:

   - Все что происходит внутри эмулятора
   - Ошибки, предупреждения, debug информация

3. **Через ADB** (если нужно):
   ```bash
   adb connect 127.0.0.1:5557
   adb shell
   ```
   - Подключаешься к Android как к обычному телефону

---

## Общая структура

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         ВНЕШНИЙ СЛОЙ                                     │
│                                                                           │
│  ┌──────────────────────┐  ┌──────────────────────┐                       │
│  │   Web UI (HTML)     │  │  Swift App (future) │                       │
│  │   http://:8090/ui  │  │  Native macOS GUI   │                       │
│  └──────────┬──────────┘  └──────────┬──────────┘                       │
│             │                         │                                   │
│             └─────────────┬───────────┘                                   │
│                           │                                               │
│                    HTTP/WebSocket                                          │
└───────────────────────────┼───────────────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    API СЛОЙ (FastAPI)                                    │
│                    core/api.py                                           │
│                                                                           │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │  REST API Endpoints:                                          │      │
│  │  - /state, /ignition/press_short, /ignition/press_long        │      │
│  │  - /emulator/start, /emulator/stop                             │      │
│  │  - /display/hu/frame, /display/cluster/frame                  │      │
│  │  - /ws/hu, /ws/cluster (WebSocket streams)                   │      │
│  │  - /can/* (CAN bus control)                                  │      │
│  │  - /qnx/* (QNX VM control)                                   │      │
│  └──────────────────────────────────────────────────────────────┘      │
│                                                                           │
│  ┌──────────────────────────────────────────────────────────────┐      │
│  │  Background Tasks:                                            │      │
│  │  - Periodic CAN connection check                              │      │
│  │  - Auto-start emulators on startup (if state requires)        │      │
│  └──────────────────────────────────────────────────────────────┘      │
└───────────────────────────┬───────────────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    ЯДРО УПРАВЛЕНИЯ (Core Layer)                         │
│                                                                           │
│  ┌──────────────────────┐  ┌──────────────────────┐                      │
│  │  StateManager       │  │  IgnitionController  │                      │
│  │  core/state_manager │  │  core/ignition_      │                      │
│  │                     │  │       controller    │                      │
│  │  - Управление       │  │  - Обработка         │                      │
│  │    состоянием       │  │    нажатий кнопки    │                      │
│  │  - Персистентность  │  │  - Запуск эмуляторов │                      │
│  │  - Observer pattern │  │  - Переходы состояний│                      │
│  └──────────┬──────────┘  └──────────┬──────────┘                      │
│             │                         │                                  │
│             └─────────────┬────────────┘                                  │
│                           │                                               │
│  ┌──────────────────────┐ │  ┌──────────────────────┐                    │
│  │  EmulatorManager     │ │  │  QnxVmManager        │                    │
│  │  core/emulator.py    │ │  │  core/qnx_vm.py      │                    │
│  │                      │ │  │                      │                    │
│  │  - Android HU VM     │ │  │  - QNX Cluster VM    │                    │
│  │  - QEMU процесс      │ │  │  - QEMU процесс      │                    │
│  │  - Конфигурация      │ │  │  - QNX консоли       │                    │
│  │  - Логирование       │ │  │  - VNC display      │                    │
│  └──────────┬───────────┘ │  └──────────┬──────────┘                    │
│             │              │              │                                │
│             └──────────────┼──────────────┘                                │
│                            │                                               │
│  ┌──────────────────────┐ │  ┌──────────────────────┐                   │
│  │  CanServer           │ │  │  DisplayFrameManager  │                   │
│  │  core/can_server.py  │ │  │  core/display_frames  │                   │
│  │                      │ │  │                      │                   │
│  │  - SocketCAN (Linux) │ │  │  - HU frames (VNC)    │                   │
│  │  - TCP fallback      │ │  │  - Cluster frames     │                   │
│  │  - CAN frame tx      │ │  │  - Pluggable providers│                   │
│  └──────────┬───────────┘ │  └──────────┬───────────┘                   │
│             │              │              │                               │
│             └──────────────┼──────────────┘                                │
│                            │                                               │
│  ┌──────────────────────┐ │  ┌──────────────────────┐                    │
│  │  CanBus (Model)      │ │  │  BootMonitor         │                    │
│  │  core/qnx.py         │ │  │  core/boot_monitor   │                    │
│  │                      │ │  │                      │                    │
│  │  - CAN frame model   │ │  │  - Boot progress      │                    │
│  │  - Message history  │ │  │  - ADB status        │                    │
│  │  - State tracking    │ │  │  - Process checks    │                    │
│  └──────────────────────┘ │  └──────────────────────┘                    │
└───────────────────────────┼───────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                    ВИРТУАЛЬНЫЕ МАШИНЫ (QEMU)                             │
│                                                                           │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │  Android HU VM (EmulatorManager)                                │   │
│  │  Machine: virt/g6sh, CPU: cortex-a57, RAM: 4GB                  │   │
│  │                                                                   │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  Образы:                                                 │   │   │
│  │  │  - boot.img (kernel + ramdisk)                           │   │   │
│  │  │  - system.img (Android system)                            │   │   │
│  │  │  - vendor.img (vendor blobs)                             │   │   │
│  │  │  - product.img (product apps)                            │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                   │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  Устройства:                                             │   │   │
│  │  │  - virtio-blk-pci (диски)                                │   │   │
│  │  │  - virtio-gpu-pci (графика)                              │   │   │
│  │  │  - virtio-net-pci (сеть, ADB :5557)                      │   │   │
│  │  │  - PL011 UART (консоль, :1234)                           │   │   │
│  │  │  - VNC display (:5900)                                   │   │   │
│  │  │  - QEMU monitor (:5558)                                  │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  └──────────────────────────────────────────────────────────────────┘   │
│                                                                           │
│  ┌──────────────────────────────────────────────────────────────────┐   │
│  │  QNX Cluster VM (QnxVmManager)                                   │   │
│  │  Machine: virt, CPU: cortex-a57, RAM: 2GB                       │   │
│  │                                                                   │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  Образы:                                                 │   │   │
│  │  │  - hypervisor-ifs-rcar_h3-graphics.bin (QNX kernel)     │   │   │
│  │  │  - qnx_system.img (QNX rootfs, optional)                  │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  │                                                                   │   │
│  │  ┌─────────────────────────────────────────────────────────┐   │   │
│  │  │  Устройства:                                             │   │   │
│  │  │  - virtio-blk-pci (QNX rootfs)                           │   │   │
│  │  │  - virtio-serial-pci (virtio-console, :1236)            │   │   │
│  │  │  - PL011 UART (консоль, :1237)                           │   │   │
│  │  │  - VNC display (:5901)                                   │   │   │
│  │  │  - QEMU monitor (:5559)                                  │   │   │
│  │  │  - CAN bus (socketcan, если Linux)                       │   │   │
│  │  └─────────────────────────────────────────────────────────┘   │   │
│  └──────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
```

## Последовательность запуска

### 1. Инициализация сервера (startup_event)

```
main.py (uvicorn)
    │
    ▼
api.py::startup_event()
    │
    ├─► StateManager() ────────────────► restore_state() (из data/vehicle_state.json)
    │
    ├─► IgnitionController(state_manager, emulator_manager, qnx_vm_manager)
    │
    ├─► Auto-start emulators (если состояние требует)
    │   └─► _ignition_controller._start_emulators_if_needed()
    │
    └─► Periodic CAN check task ──────► _periodic_can_check() (каждые 2 сек)
```

### 2. Нажатие кнопки зажигания (short press)

```
Web UI → POST /ignition/press_short
    │
    ▼
api.py::ignition_press_short()
    │
    ▼
IgnitionController::handle_short_press()
    │
    ├─► Определение нового состояния:
    │   OFF → POWER_READY (если driver_ready)
    │   POWER_READY → ACC_ON
    │   ACC_ON → OFF
    │   ENGINE_RUNNING → ACC_ON
    │
    ├─► StateManager::set_ignition_state(new_state)
    │   │
    │   ├─► Сохранение в data/vehicle_state.json
    │   └─► Уведомление observers
    │
    ├─► _emit_ignition_can_messages() ───► CanBus::emit_*()
    │   │                                    │
    │   │                                    ▼
    │   └────────────────────────────────► CanServer::transmit_frame()
    │                                          │
    │                                          ▼
    │                                    SocketCAN / TCP socket
    │                                    (передача в QNX VM)
    │
    └─► _on_state_changed() ────────────► _start_emulators_if_needed()
            │
            ├─► POWER_READY ────────────► QnxVmManager::start()
            │                               │
            │                               ├─► build_qemu_args()
            │                               ├─► cleanup old processes
            │                               └─► subprocess.Popen(qemu-system-aarch64)
            │
            ├─► ACC_ON ──────────────────► EmulatorManager::start()
            │   │                           │
            │   │                           ├─► build_qemu_args()
            │   │                           ├─► cleanup old processes
            │   │                           ├─► subprocess.Popen(qemu-system-aarch64)
            │   │                           └─► _start_adb_logger() ──► adb logcat
            │   │
            │   └────────────────────────► QnxVmManager::start()
            │
            └─► ENGINE_RUNNING ──────────► EmulatorManager::start()
                                            └─► QnxVmManager::start()
```

### 3. Запуск QEMU процессов

#### Android HU VM (EmulatorManager)

```bash
qemu-system-aarch64 \
  -M virt,highmem=on \
  -cpu cortex-a57 \
  -smp 4 \
  -m 4096 \
  -kernel boot.img \
  -append "console=ttyAMA0,115200 androidboot.selinux=permissive ..." \
  -drive file=system.img,format=raw,id=system \
  -device virtio-blk-pci,drive=system \
  -drive file=vendor.img,format=raw,id=vendor \
  -device virtio-blk-pci,drive=vendor \
  -drive file=product.img,format=raw,id=product \
  -device virtio-blk-pci,drive=product \
  -device virtio-gpu-pci \
  -netdev user,id=net0,hostfwd=tcp::5557-:5555 \
  -device virtio-net-pci,netdev=net0 \
  -display vnc=127.0.0.1:0 \
  -monitor tcp:127.0.0.1:5558,server,nowait \
  -serial file:logs/qemu_console.log \
  -no-reboot -no-shutdown
```

#### QNX Cluster VM (QnxVmManager)

```bash
qemu-system-aarch64 \
  -M virt \
  -cpu cortex-a57 \
  -smp 2 \
  -m 2048 \
  -kernel hypervisor-ifs-rcar_h3-graphics.bin \
  -drive file=qnx_system.img,format=raw,read-only=on,id=qnxsys \
  -device virtio-blk-pci,drive=qnxsys \
  -device virtio-serial-pci,id=qnx_virtio_serial0 \
  -chardev socket,id=qnx_virtcon,host=localhost,port=1236,server=on,wait=off \
  -device virtconsole,chardev=qnx_virtcon,name=qnx-virtcon0 \
  -chardev socket,id=qnx_pl011,host=localhost,port=1237,server=on,wait=off \
  -serial chardev:qnx_pl011 \
  -display vnc=127.0.0.1:1 \
  -monitor tcp:127.0.0.1:5559,server,nowait \
  -no-reboot -no-shutdown
```

## Компоненты и их ответственность

### StateManager (`core/state_manager.py`)

- **Ответственность**: Централизованное управление состоянием автомобиля
- **Хранит**: IgnitionState, alarm_armed, doors, driver_ready, proximity_detected, engine_running
- **Персистентность**: Автоматическое сохранение в `data/vehicle_state.json`
- **Паттерн**: Observer pattern для уведомления об изменениях

### IgnitionController (`core/ignition_controller.py`)

- **Ответственность**: Логика переходов состояний зажигания
- **Обрабатывает**: Short press, Long press
- **Управляет**: Запуск/остановка эмуляторов в зависимости от состояния
- **Состояния**: OFF → POWER_READY → ACC_ON → ENGINE_RUNNING

### EmulatorManager (`core/emulator.py`)

- **Ответственность**: Управление Android HU виртуальной машиной
- **Задачи**:
  - Построение QEMU командной строки
  - Запуск/остановка QEMU процесса
  - Мониторинг состояния (PID, статус)
  - Логирование (emulator_core.log, qemu_stdout.log)
  - Запуск ADB logcat для Android логов

### QnxVmManager (`core/qnx_vm.py`)

- **Ответственность**: Управление QNX Cluster виртуальной машиной
- **Задачи**:
  - Построение QEMU командной строки для QNX
  - Запуск/остановка QEMU процесса
  - Управление QNX консолями (PL011, virtio-console)
  - Логирование (qnx_qemu_stdout.log)

### CanServer (`core/can_server.py`)

- **Ответственность**: Передача CAN фреймов в QNX VM
- **Режимы**:
  - SocketCAN (Linux, предпочтительно) - прямое подключение к vcan0
  - TCP socket (fallback, macOS/Windows) - для будущей интеграции
- **Порты**: 1238 (TCP), vcan0 (SocketCAN)

### CanBus (`core/qnx.py`)

- **Ответственность**: Модель CAN шины
- **Функции**:
  - Генерация CAN фреймов (ignition, engine, doors, proximity, etc.)
  - История сообщений (до 100 событий)
  - Трекинг состояния (headlights_on, doors_unlocked, etc.)

### DisplayFrameManager (`core/display_frames.py`)

- **Ответственность**: Управление кадрами для дисплеев
- **Провайдеры**:
  - VNC (через `graphics_vnc.py`) - реальные кадры из QEMU
  - Local PNG (fallback) - статические кадры из boot animation
- **API**: `next_hu_frame()`, `next_cluster_frame()`

### BootMonitor (`core/boot_monitor.py`)

- **Ответственность**: Мониторинг процесса загрузки
- **Проверяет**:
  - Активность логов (Android, QNX)
  - Статус ADB подключения
  - Состояние процессов QEMU
  - Доступность портов (VNC, ADB, мониторы)

## Потоки данных

### 1. Управление состоянием

```
Web UI → API → IgnitionController → StateManager → persistence
                                      │
                                      └─► Observer notifications
```

### 2. CAN сообщения

```
API /can/* → CanBus::emit_*() → CanServer::transmit_frame()
                                      │
                                      ├─► SocketCAN (Linux) → vcan0 → QEMU → QNX
                                      └─► TCP socket (macOS/Windows, future)
```

### 3. Видео потоки

```
QEMU VNC (:5900, :5901)
    │
    ▼
graphics_vnc.py::hu_vnc_frame() / cluster_vnc_frame()
    │
    ▼
DisplayFrameManager::next_hu_frame() / next_cluster_frame()
    │
    ├─► GET /display/hu/frame (HTTP polling)
    └─► WS /ws/hu, /ws/cluster (WebSocket streaming)
```

### 4. Логи

```
QEMU stdout/stderr → logs/qemu_stdout.log
QEMU console (UART) → logs/qemu_console.log
ADB logcat → logs/adb_android.log
QNX QEMU → logs/qnx_qemu_stdout.log
QNX PL011 → QnxPl011Console (socket :1237)
QNX virtio → QnxVirtioConsole (socket :1236)
Core → logs/emulator_core.log
CAN → logs/can_server.log
    │
    ▼
GET /logs/combined → CombinedLogsResponse
```

## Порты и интерфейсы

| Порт  | Протокол  | Назначение             | Компонент         |
| ----- | --------- | ---------------------- | ----------------- |
| 8090  | HTTP/WS   | API сервер             | FastAPI (main.py) |
| 5557  | TCP       | ADB (Android)          | QEMU Android VM   |
| 5558  | TCP       | QEMU Monitor (Android) | QEMU Android VM   |
| 5559  | TCP       | QEMU Monitor (QNX)     | QEMU QNX VM       |
| 5900  | VNC       | HU Display             | QEMU Android VM   |
| 5901  | VNC       | Cluster Display        | QEMU QNX VM       |
| 1236  | TCP       | QNX virtio-console     | QEMU QNX VM       |
| 1237  | TCP       | QNX PL011 console      | QEMU QNX VM       |
| 1238  | TCP       | CAN Server             | CanServer         |
| vcan0 | SocketCAN | CAN Bus (Linux)        | CanServer → QEMU  |

## Файловая структура

```
Development/Chery_Emulator/
├── main.py                    # Точка входа (uvicorn)
├── emulator_config.yaml       # Конфигурация образов
├── core/
│   ├── api.py                 # FastAPI приложение, все endpoints
│   ├── emulator.py            # EmulatorManager (Android HU)
│   ├── qnx_vm.py              # QnxVmManager (QNX Cluster)
│   ├── state_manager.py       # StateManager
│   ├── state.py               # VehicleState, IgnitionState
│   ├── state_persistence.py   # Сохранение/загрузка состояния
│   ├── ignition_controller.py # IgnitionController
│   ├── can_server.py          # CanServer
│   ├── can_bridge.py          # CanBridge (future)
│   ├── qnx.py                 # CanBus, QnxConsole classes
│   ├── display_frames.py      # DisplayFrameManager
│   ├── graphics_vnc.py        # VNC frame providers
│   ├── vnc_client.py          # VNC client (future)
│   ├── boot_monitor.py        # BootMonitor
│   ├── boot_extractor.py      # Извлечение kernel из boot.img
│   ├── qemu_monitor.py        # QEMU monitor client
│   ├── process_cleanup.py     # Очистка процессов/портов
│   ├── controls.py            # ControlsState, команды
│   ├── api_controls.py        # Controls API endpoints
│   └── config.py              # Конфигурация
├── web/
│   └── index.html             # Web UI
├── data/
│   └── vehicle_state.json     # Сохраненное состояние
├── logs/
│   ├── emulator_core.log       # Core логи
│   ├── qemu_stdout.log         # Android QEMU stdout
│   ├── qemu_console.log        # Android UART console
│   ├── qnx_qemu_stdout.log     # QNX QEMU stdout
│   ├── adb_android.log         # Android logcat
│   ├── can_server.log          # CAN server логи
│   ├── api_server.log          # API логи
│   └── qemu_command.txt        # Последняя QEMU команда
└── payload/
    ├── boot.img                # Android boot image
    ├── system.img              # Android system
    ├── vendor.img              # Android vendor
    ├── product.img             # Android product
    ├── qnx_boot.img            # QNX boot (optional)
    └── qnx_system.img          # QNX system (optional)
```

## Состояния и переходы

### IgnitionState

```
OFF
  │ (short press, driver_ready)
  ▼
POWER_READY ────► QNX VM starts
  │ (short press)
  ▼
ACC_ON ──────────► Android HU + QNX VM start
  │ (short press)
  ▼
OFF (shutdown)
  │
  │ (long press from ACC_ON)
  ▼
ENGINE_RUNNING ──► engine_running = True
  │ (short press)
  ▼
ACC_ON (engine continues running)
```

### EmulatorStatus / QnxVmStatus

```
STOPPED
  │ (start())
  ▼
STARTING
  │ (QEMU process spawned)
  ▼
RUNNING
  │ (stop())
  ▼
STOPPING
  │ (process terminated)
  ▼
STOPPED
  │ (error)
  ▼
ERROR
```

## Зависимости между компонентами

```
main.py
  └─► api.py (FastAPI app)
      │
      ├─► StateManager (singleton)
      │   └─► state_persistence.py
      │
      ├─► IgnitionController
      │   ├─► StateManager
      │   ├─► EmulatorManager
      │   └─► QnxVmManager
      │
      ├─► EmulatorManager
      │   ├─► EmulatorConfig (from YAML)
      │   ├─► process_cleanup.py
      │   └─► boot_extractor.py
      │
      ├─► QnxVmManager
      │   └─► EmulatorConfig (from YAML)
      │
      ├─► CanServer
      │   └─► CanBus (from qnx.py)
      │
      ├─► DisplayFrameManager
      │   └─► graphics_vnc.py
      │
      └─► BootMonitor
          └─► logs/ directory
```

## Асинхронность

- **FastAPI**: Асинхронный HTTP/WebSocket сервер
- **QEMU процессы**: Запускаются в `run_in_executor()` чтобы не блокировать event loop
- **CAN transmission**: Неблокирующая, ошибки логируются
- **VNC frame capture**: В `run_in_executor()` для избежания блокировки
- **Background tasks**: Периодические проверки (CAN connection, auto-start)

## Безопасность и изоляция

- **Process isolation**: Каждый QEMU процесс изолирован
- **Port cleanup**: Автоматическая очистка портов перед запуском
- **Graceful shutdown**: SIGTERM → SIGKILL с таймаутами
- **Error handling**: Все ошибки логируются, не падают приложение
- **State persistence**: Состояние сохраняется при каждом изменении

## Расширяемость

- **Pluggable providers**: DisplayFrameManager поддерживает замену провайдеров
- **Observer pattern**: StateManager позволяет добавлять observers
- **Modular API**: Новые endpoints легко добавлять в api.py
- **Config-driven**: Конфигурация через YAML, не требует перекомпиляции
