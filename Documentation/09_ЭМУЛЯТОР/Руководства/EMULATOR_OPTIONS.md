# Варианты эмуляторов для g6sh

## Текущая проблема
QEMU virt machine не может напрямую маппить адреса g6sh (0xe6e80000) на PL011. Ядро ожидает SCIF на реальных адресах.

## Варианты решения

### 1. **Renode** (рекомендуется для кастомных платформ)
**Установка:**
```bash
# Через pip
pip install renode

# Или скачать с https://github.com/renode/renode/releases
```

**Плюсы:**
- Легко добавлять кастомные устройства через Python/REPL
- Поддержка кастомных адресов и устройств
- Специально создан для встроенных систем
- Хорошая документация

**Минусы:**
- Нужно переписать конфигурацию с нуля
- Другая архитектура (не QEMU)
- Может быть медленнее

### 2. **Кастомизация QEMU** (полноценное решение)
**Требует:** Компиляция QEMU из исходников

**Шаги:**
```bash
git clone https://git.qemu.org/git/qemu.git
cd qemu
# Добавить поддержку g6sh в hw/arm/
./configure --target-list=aarch64-softmmu
make -j$(nproc)
```

**Плюсы:** Полная эмуляция g6sh
**Минусы:** Требует глубоких знаний, долгая разработка

### 3. **QEMU с правильным DTB маппингом** (текущий подход)
**Проблема:** QEMU не может динамически маппить адреса без изменения исходников

**Возможное решение:** Использовать device tree overlay или попробовать заставить ядро работать с virt адресами

### 4. **ARM Fast Models** (коммерческий)
**Плюсы:** Официальная поддержка R-Car платформ
**Минусы:** Коммерческий, дорогой

## Рекомендация

**Сейчас:** Продолжить работу с QEMU, попробовав заставить ядро работать с virt адресами через правильную конфигурацию DTB

**Если не сработает:** Попробовать Renode - он специально создан для таких задач

## Следующие шаги

1. Попробовать использовать QEMU с правильной конфигурацией DTB, которая маппит адреса
2. Если не сработает - установить и попробовать Renode
3. В крайнем случае - начать кастомизацию QEMU

