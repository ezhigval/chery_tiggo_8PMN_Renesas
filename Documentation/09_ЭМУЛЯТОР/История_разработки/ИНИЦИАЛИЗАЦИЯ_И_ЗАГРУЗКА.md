# Инициализация и загрузка эмулятора

## Резюме

Документ описывает процесс инициализации QEMU, загрузку Android boot.img и решение проблем с инициализацией.

---

## Последовательность инициализации QEMU

### 1. Запуск QEMU

Python запускает `qemu-system-aarch64` через subprocess с аргументами командной строки.

### 2. Парсинг аргументов

- QEMU парсит аргументы (`-M g6sh`, `-chardev`, `-serial`, etc.)
- Создаются chardev устройства из аргументов `-chardev`
- Если есть `-serial`, создается chardev автоматически (отключено для g6sh)

### 3. Регистрация машины

- Вызывается `type_init(g6sh_machine_type_init)`
- Регистрируется машина `g6sh`
- Машина наследуется от `TYPE_VIRT_MACHINE`

### 4. Инициализация машины

- Вызывается `machvirt_init(MachineState *machine)`
- Создаются устройства в определенном порядке:
  1. Загрузка kernel из boot.img
  2. Создание UART устройств
  3. Создание других периферийных устройств

### 5. Загрузка Android boot.img

#### Процесс загрузки

1. **Обнаружение boot.img**
   - QEMU проверяет, является ли переданный файл Android boot.img
   - Проверяется магический номер `ANDROID_BOOT_MAGIC`

2. **Парсинг header**
   - Читается header boot.img (2048 байт)
   - Извлекаются адреса:
     - `kernel_addr` (обычно 0x48080000 для g6sh)
     - `ramdisk_addr` (обычно 0x4a180000)
   - Извлекается `page_size` для расчета смещений

3. **Загрузка kernel**
   - Kernel извлекается из boot.img по offset: `page_size`
   - Загружается в виртуальную память по адресу `kernel_addr`
   - Размер kernel читается из header

4. **Загрузка ramdisk**
   - Ramdisk извлекается по offset: `page_size + kernel_size` (выровнено по page_size)
   - Загружается в виртуальную память по адресу `ramdisk_addr`

5. **Передача параметров**
   - Kernel cmdline передается через `-append`
   - DTB (Device Tree Blob) передается через `-dtb` (если указан)

#### Логи успешной загрузки

```
=== machvirt_init CALLED ===
=== BEFORE arm_load_kernel ===
=== arm_setup_direct_kernel_boot CALLED ===
Android boot.img detected: kernel_addr=0x48080000, ramdisk_addr=0x4a180000
Loading Android kernel to 0x48080000 (size 9098310 bytes)
Loading Android ramdisk to 0x4a180000 (size 5519955 bytes)
Android boot.img loaded successfully
```

---

## Проблемы и решения

### Проблема 1: Неправильный offset для kernel

**Симптом:** Kernel не загружался или загружался по неправильному адресу.

**Причина:** Использовался фиксированный offset вместо `page_size` из header.

**Решение:**
```c
// android_bootimg.c
uint32_t page_size = header->page_size;
uint64_t kernel_offset = page_size;  // Вместо фиксированного значения
```

### Проблема 2: Конфликт chardev при инициализации

**Симптом:** Ошибка "Device 'serial0'/'console0' is in use" при создании UART.

**Причина:** Автоматическое создание chardev устройствами QEMU.

**Решение:** Отключение автоматического создания (см. [CHARDEV_ПРОБЛЕМА_И_РЕШЕНИЕ.md](./CHARDEV_ПРОБЛЕМА_И_РЕШЕНИЕ.md))

---

## Ключевые моменты

1. **Порядок инициализации критичен**
   - Chardev должны быть созданы до использования
   - Kernel должен быть загружен до создания устройств, которые от него зависят

2. **Android boot.img парсер**
   - Использует `page_size` из header для расчета смещений
   - Поддерживает разные адреса загрузки (0x48080000 для g6sh, 0x40080000 для virt)

3. **Упрощение g6sh машины**
   - Использует родительский init от virt машины
   - Автоматически получает Android boot.img парсер
   - Минимальные изменения в коде

---

## Измененные файлы

1. `qemu_g6sh/qemu-src/hw/arm/android_bootimg.c` - исправлен offset для kernel
2. `qemu_g6sh/qemu-src/hw/arm/g6sh.c` - упрощена реализация
3. `qemu_g6sh/qemu-src/hw/arm/virt.c` - условное создание UART
4. `Development/Chery_Emulator/core/emulator.py` - уникальный chardev для g6sh

---

## Статус

✅ **Инициализация работает корректно**

- Kernel загружается на правильный адрес
- Ramdisk загружается корректно
- UART устройства создаются без конфликтов
- Android система начинает загрузку

