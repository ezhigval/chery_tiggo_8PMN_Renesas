# Полная модель копии головного устройства G6SH/T18FL3

**Цель:** описать **полную информационную модель** головы (железо → загрузка → разделы → QNX ↔ Android ↔ MCU → приложения),
которую нужно восстановить в эмуляторе, чтобы он вёл себя как реальное устройство.

Эта модель описывает **что** мы должны знать и сохранить. Отдельный план **как** это собрать — в `FULL_SYSTEM_DATA_COLLECTION_PLAN.md`.

---

## 1. Общая структура системы

### 1.1. Слои

- **Железо**
  - SoC: Renesas R-Car H3 (`r8a7795`), ядра A53/A57, контроллеры.
  - Память: RAM, eMMC, NOR, периферия.
  - Интерфейсы: UART, USB, Ethernet, CAN, LVDS/панель, аудио, камеры.
- **Загрузочная цепочка**
  - ROM → bootloader в NOR → выбор слота A/B → загрузка Android/QNX.
  - Правила fallback по слотам (A/B для Android, A/B для QNX).
- **Хранилище**
  - eMMC: GPT/разделы Android и QNX.
  - NOR: образ загрузчика.
- **ОС-уровень**
  - Android: Linux kernel, ramdisk, system/vendor/product.
  - QNX: образы `qnx_boot_*`, `qnx_system_*`, `qnx_app*`, `qnx_userdata`, `qnx_firmware`.
- **Интеграция QNX/MCU**
  - Virtio shared memory (`qnx-virtio-du`, `guest_shm`).
  - Virtio block (`virtio_blk` для qnx_* разделов).
  - Virtio/remoteproc serial (`virtio_rproc_serial`).
  - Виртуальная сеть (192.168.2.1/2, порты 10004/10005/31030/31040/31050).
- **Прикладная логика**
  - Системные сервисы Desay/Android (CarService, Vehicle LAN, LinkDeviceManager и т.п.).
  - QNX-сервисы и их API (приборка, MCU, CAN, DSP, камеры).
  - UI/launcher, настройки, подсистемы (медиа, навигация, климат, парктроник).

---

## 2. Что именно должно быть скопировано (артефакты)

### 2.1. Железо (логическая модель)

**Задача:** для эмулятора не нужны физические схемы, но нужна **логическая модель железа**, совпадающая с тем, что видит ядро и userspace.

- **CPU и SoC**
  - Архитектура, число ядер, частоты (как минимум логическая топология).
  - Особенности: big.LITTLE, timers, GIC, PMU.
- **Память**
  - Объём RAM.
  - Карта адресного пространства (дамп из device tree + `/proc/iomem`).
- **Шины и контроллеры**
  - UART контроллеры (PL011/HSCIF) и их base-адреса/IRQ.
  - USB контроллер.
  - Ethernet MAC/PHY.
  - Контроллеры дисплея и камеры.
  - Аудио кодек/звук.
- **Экран**
  - Физическое разрешение.
  - DPI/плотность.
  - Ориентация и логическое разрешение, которое видит Android.
- **Входы/выходы**
  - Touch/кнопки руля/крутилки → какие input-устройства и keycodes.
  - Сенсоры (GPS, гироскоп, датчики света/парктроника).

Все эти данные должны быть или:

- Вытянуты из **device tree** (см. `DEVICE_TREE_*` файлы и `g6sh-emu.dts`),
- Зафиксированы через `/proc`, `/sys`, `getevent`, `dumpsys` и сохранены в текстовом виде.

### 2.2. Загрузочная цепочка и правила слотов

- Версия bootloader’а (уже зафиксирована в `BOOTLOADER_UNLOCK_ANALYSIS.md`).
- **Правила выбора слота**:
  - Какие переменные/partition flags определяют активный слот.
  - Как устройство переключает слот при ошибке (Android A/B + QNX A/B).
- **Командная строка ядра (cmdline)**:
  - console, selinux, verity, qnx-параметры.
- **Проверки целостности и подписи**:
  - dm-verity режим (сейчас `eio`).
  - Проверка подписи образов (где, кем, при каких условиях).

Для эмулятора важно:

- Воспроизвести **тот же cmdline**.
- Заложить те же правила слотов (даже если часть будет «фиктивной», они должны совпадать логически).

### 2.3. Разделы и файловые системы

**Нужно:**

- Полный список разделов:
  - `/dev/block/by-name/*` + размеры (`blockdev --getsize64`).
  - Типы (GPT-запись, `blkid`).
- Полные **образы всех разделов**: Android + QNX + служебные.

Логическая модель:

- Где лежат:
  - `bootloader_*`, `boot_*`, `system_*`, `vendor`, `product`, `userdata`, …
  - `qnx_boot_*`, `qnx_system_*`, `qnx_appcfg`, `qnx_appdata`, `qnx_userdata`, `qnx_firmware`.
- Как эти разделы видят:
  - Android (`/dev/block/platform/*`).
  - QNX (через virtio_blk).

Эта информация критична для:

- Сборки единого `emmc_full.img` **или** реконструкции eMMC из отдельных img.
- Настройки QEMU-платы (привязка разделов к виртуальным устройствам).

### 2.4. Android слой (ядро, система, сервисы)

- **Ядро Android**
  - Версия (уже зафиксирована).
  - Конфигурация (`/proc/config.gz` или эквивалент).
  - Список загруженных модулей (если используются).
- **Ramdisk и init-скрипты**
  - Содержимое `init*.rc` (часть уже в `extracted_files/init_scripts`).
  - Sequential boot: какие сервисы стартуют Android, QNX, MCU-интеграцию.
- **System/vendor/product**
  - Ключевые бинарники (особенно для vehicle/QNX).
  - Библиотеки `.so` для automotive/QNX/vehicle.
  - Конфиги `/system/etc`, `/vendor/etc`, `/oem`, `/persist` с QNX/vehicle.
- **Системные сервисы и процессы**
  - `car_service`, `dsv_car_power`, `linkdevicemanager`, `shmemservice`, `vehiclelan_service` и т.д.
  - Их параметры запуска, binder интерфейсы, порты, к каким разделам/устройствам привязаны.

### 2.5. QNX слой и его интеграция

- **Образы QNX** (см. 2.3).
- **Интерфейсы интеграции**:
  - `qnx-virtio-du` + `guest_shm` (дисплей и/или другие данные).
  - `virtio_blk` устройства под qnx_*.
  - `virtio_rproc_serial` как RPC/сообщения.
  - Виртуальный Ethernet (192.168.2.1/2, порты).
- **Сервисы QNX**:
  - Приборка, MCU, CAN, DSP, камеры, парктроник, климат.
  - Как QNX сообщает состояние обратно Android (events/packets).

Задача модели: описать **какой именно канал за что отвечает**
(например: какой порт/virtio сериал отвечает за «заднюю передачу» или «скорость авто»).

### 2.6. MCU / CAN / «электрика» (логический уровень)

Физические сигналы (ACC, IGN, двери, скорость, шифтер, ручник, датчики) переводим в **логические события**:

- Откуда приходят:
  - QNX → Android (через сеть / virtio / serial).
  - Прямо в Android (редко, но возможно).
- Как видны:
  - В свойствах (`getprop`).
  - В логах (`logcat`, `dmesg`).
  - В сервисах (`dumpsys` автомобилей/кластера).

Нужно зафиксировать:

- Маппинг «физическое событие → конкретное сообщение/поле протокола/сервис».
- Минимальный набор состояний, который нужен для:
  - включения/выключения головы,
  - задней передачи и парктроника,
  - движения и скорости,
  - дверей/ремней и т.п.

### 2.7. UI, разрешение, layout

- **Экран Android**
  - `wm size`, `wm density`, реальное разрешение панели.
  - Поддерживаемые конфигурации (вторая панель, если есть).
- **Связь с QNX**
  - Какие данные/виджеты отдаются на приборку (навигатор, стрелки, скорость, медиа).
  - Через какой канал (сеть/virtio/serial).

Для эмулятора:

- UI должен рендериться в том же логическом разрешении.
- Канал на приборку может быть:
  - Реальной второй панелью,
  - Логическим «вторым дисплеем» (QEMU + QNX),
  - Или эмуляцией в отдельном окне/программе.

### 2.8. «Принципы, проверки и правила»

Сюда попадает всё, что определяет поведение системы, кроме «сырых данных»:

- **Правила загрузки и отката слотов**.
- **Проверки целостности и подписей** (dm-verity, сигнатуры OTA, контроль версий MCU/QNX).
- **Power-политики**:
  - Когда голова засыпает/просыпается.
  - Как ведут себя QNX/Android при быстрых on/off.
- **Состояние безопасности**:
  - Ограничения ADB/ENG режимов.
  - Политики, завязанные на передаче данных наружу.

Эти вещи критичны, чтобы эмулятор:

- Вёл себя как реальное устройство при «нештатных» сценариях,
- Но при этом мы могли **подкручивать** или отключать отдельные проверки для разработки (например, verity).

---

## 3. Карта уже существующих материалов

Чтобы не дублировать:

- `REVERSE_ENGINEERING_REPORT.md` — базовая системная инфа (CPU, свойства, порты, сервисы).
- `DEVICE_TREE_SUMMARY.md`, `DEVICE_TREE_UART_ANALYSIS.md`, `g6sh-emu.dts` — карта железа и UART/DT для эмулятора.
- `BOOTLOADER_UNLOCK_ANALYSIS.md` — статус загрузчика, A/B, verity, режимы безопасности.
- `QNX_CONNECTION_ANALYSIS.md`, `QNX_DATA_EXTRACTION_PLAN.md`, `QNX_EXTRACTION_SUMMARY.md` — каналы к QNX, уже найденные интерфейсы и план выкачки.
- `EXTRACTION_SUMMARY.md`, `extracted_files/*` — уже вытянутые APK/бинарники/скрипты.
- `FULL_SYSTEM_INSTALL_PLAN.md`, `INSTALL_MODIFIED_IMAGE_PLAN.md` — планы по установке/модификации образов.

Эта модель должна **ссылаться** на существующие документы и расширяться,
а не создавать дублирующие версии тех же фактов.

---

## 4. Что ещё нужно доснять / доописать

Список «дыр» в текущей картине, которые нужно закрыть до того, как собирать эмулятор:

- **Железо**
  - Полная карта адресов и IRQ из DT + `/proc/iomem`.
  - Явная таблица: «железный блок → dt-нод → /dev-устройство → кто в userspace им пользуется».
- **eMMC/NOR**
  - Полный дамп GPT/partition table.
  - Битовые образы всех разделов (Android + QNX + служебные).
- **Boot chain**
  - Полный `cmdline` + пояснения каждого параметра, влияющего на QNX, verity, debug.
- **Интеграция QNX/MCU**
  - Лог протоколов по портам 10004/10005/31030/31040/31050 при разных событиях.
  - Фиксация форматов сообщений (хотя бы первая версия).
- **MCU/CAN**
  - Карта: какое событие автомобиля даёт какой эффект/сообщение.
- **UI/дисплеи**
  - Полная инфа о дисплеях (основной, вторичный, приборка) и связях между ними.

Конкретные команды и шаги, как это собрать, описаны в `FULL_SYSTEM_DATA_COLLECTION_PLAN.md`.

---

## 5. Целевая картинка для эмулятора

Когда эта модель будет заполнена:

- Будет возможно собрать QEMU-плату `g6sh` с:
  - Полным образом eMMC.
  - Реалистичным DT (на базе `g6sh-emu.dts`).
  - Virtio-подсистемой для QNX/MCU.
  - UART/сетевыми каналами, подключёнными к нашим симуляторам.
- Мы сможем запустить:
  - Родной bootloader → Android → QNX.
  - Система будет видеть **те же разделы, свойства, сервисы и протоколы**, что и на реальном железе.
- Поверх этого можно будет строить:
  - Симулятор MCU/CAN.
  - Автотесты состояний (зажигание, двери, движение и т.п.).

Этот файл — «карта местности».
Следующий шаг — **собрать все недостающие данные по этой карте** (см. план сбора).


